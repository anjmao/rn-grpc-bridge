// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: book.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Book_EnumSample: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case started // = 1
  static let running = started
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .started
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .started: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

struct Book_Book {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isbn: Int64 {
    get {return _storage._isbn}
    set {_uniqueStorage()._isbn = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var author: String {
    get {return _storage._author}
    set {_uniqueStorage()._author = newValue}
  }

  var pages: Int32 {
    get {return _storage._pages}
    set {_uniqueStorage()._pages = newValue}
  }

  var isActivate: Bool {
    get {return _storage._isActivate}
    set {_uniqueStorage()._isActivate = newValue}
  }

  var details: Book_BookDetails {
    get {return _storage._details ?? Book_BookDetails()}
    set {_uniqueStorage()._details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return _storage._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {_storage._details = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Book_BookDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pages: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Book_GetBookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isbn: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Book_GetBooksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [Book_Book] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Book_GetBookViaAuthor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var author: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Book_GetTypesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dbl: Double {
    get {return _storage._dbl}
    set {_uniqueStorage()._dbl = newValue}
  }

  var flt: Float {
    get {return _storage._flt}
    set {_uniqueStorage()._flt = newValue}
  }

  var intr32: Int32 {
    get {return _storage._intr32}
    set {_uniqueStorage()._intr32 = newValue}
  }

  var intr64: Int64 {
    get {return _storage._intr64}
    set {_uniqueStorage()._intr64 = newValue}
  }

  var uintr32: UInt32 {
    get {return _storage._uintr32}
    set {_uniqueStorage()._uintr32 = newValue}
  }

  var uintr64: UInt64 {
    get {return _storage._uintr64}
    set {_uniqueStorage()._uintr64 = newValue}
  }

  var suint32: Int32 {
    get {return _storage._suint32}
    set {_uniqueStorage()._suint32 = newValue}
  }

  var suint64: Int64 {
    get {return _storage._suint64}
    set {_uniqueStorage()._suint64 = newValue}
  }

  var fxd32: UInt32 {
    get {return _storage._fxd32}
    set {_uniqueStorage()._fxd32 = newValue}
  }

  var fxd64: UInt64 {
    get {return _storage._fxd64}
    set {_uniqueStorage()._fxd64 = newValue}
  }

  var sfxd32: Int32 {
    get {return _storage._sfxd32}
    set {_uniqueStorage()._sfxd32 = newValue}
  }

  var sfxd64: Int64 {
    get {return _storage._sfxd64}
    set {_uniqueStorage()._sfxd64 = newValue}
  }

  var bln: Bool {
    get {return _storage._bln}
    set {_uniqueStorage()._bln = newValue}
  }

  var str: String {
    get {return _storage._str}
    set {_uniqueStorage()._str = newValue}
  }

  var bytx: Data {
    get {return _storage._bytx}
    set {_uniqueStorage()._bytx = newValue}
  }

  var books: [Book_Book] {
    get {return _storage._books}
    set {_uniqueStorage()._books = newValue}
  }

  var book: Book_Book {
    get {return _storage._book ?? Book_Book()}
    set {_uniqueStorage()._book = newValue}
  }
  /// Returns true if `book` has been explicitly set.
  var hasBook: Bool {return _storage._book != nil}
  /// Clears the value of `book`. Subsequent reads from it will return its default value.
  mutating func clearBook() {_storage._book = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Book_GetTypesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dbl: Double {
    get {return _storage._dbl}
    set {_uniqueStorage()._dbl = newValue}
  }

  var flt: Float {
    get {return _storage._flt}
    set {_uniqueStorage()._flt = newValue}
  }

  var intr32: Int32 {
    get {return _storage._intr32}
    set {_uniqueStorage()._intr32 = newValue}
  }

  var intr64: Int64 {
    get {return _storage._intr64}
    set {_uniqueStorage()._intr64 = newValue}
  }

  var uintr32: UInt32 {
    get {return _storage._uintr32}
    set {_uniqueStorage()._uintr32 = newValue}
  }

  var uintr64: UInt64 {
    get {return _storage._uintr64}
    set {_uniqueStorage()._uintr64 = newValue}
  }

  var suint32: Int32 {
    get {return _storage._suint32}
    set {_uniqueStorage()._suint32 = newValue}
  }

  var suint64: Int64 {
    get {return _storage._suint64}
    set {_uniqueStorage()._suint64 = newValue}
  }

  var fxd32: UInt32 {
    get {return _storage._fxd32}
    set {_uniqueStorage()._fxd32 = newValue}
  }

  var fxd64: UInt64 {
    get {return _storage._fxd64}
    set {_uniqueStorage()._fxd64 = newValue}
  }

  var sfxd32: Int32 {
    get {return _storage._sfxd32}
    set {_uniqueStorage()._sfxd32 = newValue}
  }

  var sfxd64: Int64 {
    get {return _storage._sfxd64}
    set {_uniqueStorage()._sfxd64 = newValue}
  }

  var bln: Bool {
    get {return _storage._bln}
    set {_uniqueStorage()._bln = newValue}
  }

  var str: String {
    get {return _storage._str}
    set {_uniqueStorage()._str = newValue}
  }

  var bytx: Data {
    get {return _storage._bytx}
    set {_uniqueStorage()._bytx = newValue}
  }

  var books: [Book_Book] {
    get {return _storage._books}
    set {_uniqueStorage()._books = newValue}
  }

  var book: Book_Book {
    get {return _storage._book ?? Book_Book()}
    set {_uniqueStorage()._book = newValue}
  }
  /// Returns true if `book` has been explicitly set.
  var hasBook: Bool {return _storage._book != nil}
  /// Clears the value of `book`. Subsequent reads from it will return its default value.
  mutating func clearBook() {_storage._book = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Book_BookStore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var books: Dictionary<Int64,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message with reserved keywords
/// see: https://github.com/google/protobuf/blob/cc3fa2ec80d196e045ae05797799f079188106f3/js/compatibility_tests/v3.0.0/test.proto#L66-L72
struct Book_SpecialCases {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var normal: String = String()

  /// Examples of Js reserved names that are converted to pb_<name>.
  var `default`: String = String()

  var function: String = String()

  var `var`: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "book"

extension Book_EnumSample: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .aliased(proto: "STARTED", aliases: ["RUNNING"]),
  ]
}

extension Book_Book: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Book"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isbn"),
    2: .same(proto: "title"),
    3: .same(proto: "author"),
    4: .same(proto: "pages"),
    5: .same(proto: "isActivate"),
    6: .same(proto: "details"),
  ]

  fileprivate class _StorageClass {
    var _isbn: Int64 = 0
    var _title: String = String()
    var _author: String = String()
    var _pages: Int32 = 0
    var _isActivate: Bool = false
    var _details: Book_BookDetails? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _isbn = source._isbn
      _title = source._title
      _author = source._author
      _pages = source._pages
      _isActivate = source._isActivate
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._isbn)
        case 2: try decoder.decodeSingularStringField(value: &_storage._title)
        case 3: try decoder.decodeSingularStringField(value: &_storage._author)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._pages)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._isActivate)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._details)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._isbn != 0 {
        try visitor.visitSingularInt64Field(value: _storage._isbn, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._author.isEmpty {
        try visitor.visitSingularStringField(value: _storage._author, fieldNumber: 3)
      }
      if _storage._pages != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pages, fieldNumber: 4)
      }
      if _storage._isActivate != false {
        try visitor.visitSingularBoolField(value: _storage._isActivate, fieldNumber: 5)
      }
      if let v = _storage._details {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_Book) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._isbn != other_storage._isbn {return false}
        if _storage._title != other_storage._title {return false}
        if _storage._author != other_storage._author {return false}
        if _storage._pages != other_storage._pages {return false}
        if _storage._isActivate != other_storage._isActivate {return false}
        if _storage._details != other_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_BookDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BookDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.pages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pages != 0 {
      try visitor.visitSingularInt32Field(value: self.pages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_BookDetails) -> Bool {
    if self.pages != other.pages {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_GetBookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBookRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isbn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.isbn)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isbn != 0 {
      try visitor.visitSingularInt64Field(value: self.isbn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_GetBookRequest) -> Bool {
    if self.isbn != other.isbn {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_GetBooksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBooksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_GetBooksResponse) -> Bool {
    if self.items != other.items {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_GetBookViaAuthor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBookViaAuthor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "author"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.author)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_GetBookViaAuthor) -> Bool {
    if self.author != other.author {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_GetTypesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTypesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dbl"),
    2: .same(proto: "flt"),
    3: .same(proto: "intr32"),
    4: .same(proto: "intr64"),
    5: .same(proto: "uintr32"),
    6: .same(proto: "uintr64"),
    7: .same(proto: "suint32"),
    8: .same(proto: "suint64"),
    9: .same(proto: "fxd32"),
    10: .same(proto: "fxd64"),
    11: .same(proto: "sfxd32"),
    12: .same(proto: "sfxd64"),
    13: .same(proto: "bln"),
    14: .same(proto: "str"),
    15: .same(proto: "bytx"),
    16: .same(proto: "books"),
    17: .same(proto: "book"),
  ]

  fileprivate class _StorageClass {
    var _dbl: Double = 0
    var _flt: Float = 0
    var _intr32: Int32 = 0
    var _intr64: Int64 = 0
    var _uintr32: UInt32 = 0
    var _uintr64: UInt64 = 0
    var _suint32: Int32 = 0
    var _suint64: Int64 = 0
    var _fxd32: UInt32 = 0
    var _fxd64: UInt64 = 0
    var _sfxd32: Int32 = 0
    var _sfxd64: Int64 = 0
    var _bln: Bool = false
    var _str: String = String()
    var _bytx: Data = SwiftProtobuf.Internal.emptyData
    var _books: [Book_Book] = []
    var _book: Book_Book? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dbl = source._dbl
      _flt = source._flt
      _intr32 = source._intr32
      _intr64 = source._intr64
      _uintr32 = source._uintr32
      _uintr64 = source._uintr64
      _suint32 = source._suint32
      _suint64 = source._suint64
      _fxd32 = source._fxd32
      _fxd64 = source._fxd64
      _sfxd32 = source._sfxd32
      _sfxd64 = source._sfxd64
      _bln = source._bln
      _str = source._str
      _bytx = source._bytx
      _books = source._books
      _book = source._book
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &_storage._dbl)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._flt)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._intr32)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._intr64)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._uintr32)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._uintr64)
        case 7: try decoder.decodeSingularSInt32Field(value: &_storage._suint32)
        case 8: try decoder.decodeSingularSInt64Field(value: &_storage._suint64)
        case 9: try decoder.decodeSingularFixed32Field(value: &_storage._fxd32)
        case 10: try decoder.decodeSingularFixed64Field(value: &_storage._fxd64)
        case 11: try decoder.decodeSingularSFixed32Field(value: &_storage._sfxd32)
        case 12: try decoder.decodeSingularSFixed64Field(value: &_storage._sfxd64)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._bln)
        case 14: try decoder.decodeSingularStringField(value: &_storage._str)
        case 15: try decoder.decodeSingularBytesField(value: &_storage._bytx)
        case 16: try decoder.decodeRepeatedMessageField(value: &_storage._books)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._book)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._dbl != 0 {
        try visitor.visitSingularDoubleField(value: _storage._dbl, fieldNumber: 1)
      }
      if _storage._flt != 0 {
        try visitor.visitSingularFloatField(value: _storage._flt, fieldNumber: 2)
      }
      if _storage._intr32 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._intr32, fieldNumber: 3)
      }
      if _storage._intr64 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._intr64, fieldNumber: 4)
      }
      if _storage._uintr32 != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._uintr32, fieldNumber: 5)
      }
      if _storage._uintr64 != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._uintr64, fieldNumber: 6)
      }
      if _storage._suint32 != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._suint32, fieldNumber: 7)
      }
      if _storage._suint64 != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._suint64, fieldNumber: 8)
      }
      if _storage._fxd32 != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._fxd32, fieldNumber: 9)
      }
      if _storage._fxd64 != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._fxd64, fieldNumber: 10)
      }
      if _storage._sfxd32 != 0 {
        try visitor.visitSingularSFixed32Field(value: _storage._sfxd32, fieldNumber: 11)
      }
      if _storage._sfxd64 != 0 {
        try visitor.visitSingularSFixed64Field(value: _storage._sfxd64, fieldNumber: 12)
      }
      if _storage._bln != false {
        try visitor.visitSingularBoolField(value: _storage._bln, fieldNumber: 13)
      }
      if !_storage._str.isEmpty {
        try visitor.visitSingularStringField(value: _storage._str, fieldNumber: 14)
      }
      if !_storage._bytx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bytx, fieldNumber: 15)
      }
      if !_storage._books.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._books, fieldNumber: 16)
      }
      if let v = _storage._book {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_GetTypesRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._dbl != other_storage._dbl {return false}
        if _storage._flt != other_storage._flt {return false}
        if _storage._intr32 != other_storage._intr32 {return false}
        if _storage._intr64 != other_storage._intr64 {return false}
        if _storage._uintr32 != other_storage._uintr32 {return false}
        if _storage._uintr64 != other_storage._uintr64 {return false}
        if _storage._suint32 != other_storage._suint32 {return false}
        if _storage._suint64 != other_storage._suint64 {return false}
        if _storage._fxd32 != other_storage._fxd32 {return false}
        if _storage._fxd64 != other_storage._fxd64 {return false}
        if _storage._sfxd32 != other_storage._sfxd32 {return false}
        if _storage._sfxd64 != other_storage._sfxd64 {return false}
        if _storage._bln != other_storage._bln {return false}
        if _storage._str != other_storage._str {return false}
        if _storage._bytx != other_storage._bytx {return false}
        if _storage._books != other_storage._books {return false}
        if _storage._book != other_storage._book {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_GetTypesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTypesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dbl"),
    2: .same(proto: "flt"),
    3: .same(proto: "intr32"),
    4: .same(proto: "intr64"),
    5: .same(proto: "uintr32"),
    6: .same(proto: "uintr64"),
    7: .same(proto: "suint32"),
    8: .same(proto: "suint64"),
    9: .same(proto: "fxd32"),
    10: .same(proto: "fxd64"),
    11: .same(proto: "sfxd32"),
    12: .same(proto: "sfxd64"),
    13: .same(proto: "bln"),
    14: .same(proto: "str"),
    15: .same(proto: "bytx"),
    16: .same(proto: "books"),
    17: .same(proto: "book"),
  ]

  fileprivate class _StorageClass {
    var _dbl: Double = 0
    var _flt: Float = 0
    var _intr32: Int32 = 0
    var _intr64: Int64 = 0
    var _uintr32: UInt32 = 0
    var _uintr64: UInt64 = 0
    var _suint32: Int32 = 0
    var _suint64: Int64 = 0
    var _fxd32: UInt32 = 0
    var _fxd64: UInt64 = 0
    var _sfxd32: Int32 = 0
    var _sfxd64: Int64 = 0
    var _bln: Bool = false
    var _str: String = String()
    var _bytx: Data = SwiftProtobuf.Internal.emptyData
    var _books: [Book_Book] = []
    var _book: Book_Book? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dbl = source._dbl
      _flt = source._flt
      _intr32 = source._intr32
      _intr64 = source._intr64
      _uintr32 = source._uintr32
      _uintr64 = source._uintr64
      _suint32 = source._suint32
      _suint64 = source._suint64
      _fxd32 = source._fxd32
      _fxd64 = source._fxd64
      _sfxd32 = source._sfxd32
      _sfxd64 = source._sfxd64
      _bln = source._bln
      _str = source._str
      _bytx = source._bytx
      _books = source._books
      _book = source._book
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularDoubleField(value: &_storage._dbl)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._flt)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._intr32)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._intr64)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._uintr32)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._uintr64)
        case 7: try decoder.decodeSingularSInt32Field(value: &_storage._suint32)
        case 8: try decoder.decodeSingularSInt64Field(value: &_storage._suint64)
        case 9: try decoder.decodeSingularFixed32Field(value: &_storage._fxd32)
        case 10: try decoder.decodeSingularFixed64Field(value: &_storage._fxd64)
        case 11: try decoder.decodeSingularSFixed32Field(value: &_storage._sfxd32)
        case 12: try decoder.decodeSingularSFixed64Field(value: &_storage._sfxd64)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._bln)
        case 14: try decoder.decodeSingularStringField(value: &_storage._str)
        case 15: try decoder.decodeSingularBytesField(value: &_storage._bytx)
        case 16: try decoder.decodeRepeatedMessageField(value: &_storage._books)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._book)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._dbl != 0 {
        try visitor.visitSingularDoubleField(value: _storage._dbl, fieldNumber: 1)
      }
      if _storage._flt != 0 {
        try visitor.visitSingularFloatField(value: _storage._flt, fieldNumber: 2)
      }
      if _storage._intr32 != 0 {
        try visitor.visitSingularInt32Field(value: _storage._intr32, fieldNumber: 3)
      }
      if _storage._intr64 != 0 {
        try visitor.visitSingularInt64Field(value: _storage._intr64, fieldNumber: 4)
      }
      if _storage._uintr32 != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._uintr32, fieldNumber: 5)
      }
      if _storage._uintr64 != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._uintr64, fieldNumber: 6)
      }
      if _storage._suint32 != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._suint32, fieldNumber: 7)
      }
      if _storage._suint64 != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._suint64, fieldNumber: 8)
      }
      if _storage._fxd32 != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._fxd32, fieldNumber: 9)
      }
      if _storage._fxd64 != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._fxd64, fieldNumber: 10)
      }
      if _storage._sfxd32 != 0 {
        try visitor.visitSingularSFixed32Field(value: _storage._sfxd32, fieldNumber: 11)
      }
      if _storage._sfxd64 != 0 {
        try visitor.visitSingularSFixed64Field(value: _storage._sfxd64, fieldNumber: 12)
      }
      if _storage._bln != false {
        try visitor.visitSingularBoolField(value: _storage._bln, fieldNumber: 13)
      }
      if !_storage._str.isEmpty {
        try visitor.visitSingularStringField(value: _storage._str, fieldNumber: 14)
      }
      if !_storage._bytx.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bytx, fieldNumber: 15)
      }
      if !_storage._books.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._books, fieldNumber: 16)
      }
      if let v = _storage._book {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_GetTypesResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._dbl != other_storage._dbl {return false}
        if _storage._flt != other_storage._flt {return false}
        if _storage._intr32 != other_storage._intr32 {return false}
        if _storage._intr64 != other_storage._intr64 {return false}
        if _storage._uintr32 != other_storage._uintr32 {return false}
        if _storage._uintr64 != other_storage._uintr64 {return false}
        if _storage._suint32 != other_storage._suint32 {return false}
        if _storage._suint64 != other_storage._suint64 {return false}
        if _storage._fxd32 != other_storage._fxd32 {return false}
        if _storage._fxd64 != other_storage._fxd64 {return false}
        if _storage._sfxd32 != other_storage._sfxd32 {return false}
        if _storage._sfxd64 != other_storage._sfxd64 {return false}
        if _storage._bln != other_storage._bln {return false}
        if _storage._str != other_storage._str {return false}
        if _storage._bytx != other_storage._bytx {return false}
        if _storage._books != other_storage._books {return false}
        if _storage._book != other_storage._book {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_BookStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BookStore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "books"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: &self.books)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.books.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: self.books, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_BookStore) -> Bool {
    if self.name != other.name {return false}
    if self.books != other.books {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Book_SpecialCases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpecialCases"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "normal"),
    2: .same(proto: "default"),
    3: .same(proto: "function"),
    4: .same(proto: "var"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.normal)
      case 2: try decoder.decodeSingularStringField(value: &self.`default`)
      case 3: try decoder.decodeSingularStringField(value: &self.function)
      case 4: try decoder.decodeSingularStringField(value: &self.`var`)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.normal.isEmpty {
      try visitor.visitSingularStringField(value: self.normal, fieldNumber: 1)
    }
    if !self.`default`.isEmpty {
      try visitor.visitSingularStringField(value: self.`default`, fieldNumber: 2)
    }
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 3)
    }
    if !self.`var`.isEmpty {
      try visitor.visitSingularStringField(value: self.`var`, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Book_SpecialCases) -> Bool {
    if self.normal != other.normal {return false}
    if self.`default` != other.`default` {return false}
    if self.function != other.function {return false}
    if self.`var` != other.`var` {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
